# フロントエンドをどうテストするか？

* 「ディスプレイ部分、コントロール部分、アウトプット部分と財布パネルの構造になるよね」というざっくりした合意が得られた
* TDD的にいうと、↑をテストを書いて、そこからコードを書き始めるのが、お作法なのか？
* 「ディスプレイ部分、コントロール部分、アウトプット部分と財布パネルの構造」をテストとして書く意味が薄いようなきがする

* 宣言的だからか？
* フィードバックループに寄与しないからでは？

* 目的: フロントエンド開発でフィードバックループを早くする方法
* 現状のよくある解: リアルタイムコンパイルで変更の結果をその度目視でチェック、いい感じになったらスナップショットを取る
* 疑問: 目視の部分をもうちょい機械でできるようにしたくない？
    * デザインを作る → コードを書く の二段階に分けるべき？
    * 例えばデザイナの持ってきたデザインをspecとして使いたいとか
        * インプット: pure html+css / figuma

* TDDになぞらえて捉えてみる
  * 捉え方
    * 我々はMiroにテストケースを書いた
    * このあとコーディングをする
    * 目視で、Miroとの差分をゆるくチェックして、パスしているか判断する

  * TDDと比べて劣る点
    * 「目視で、Miroとの差分をゆるくチェックして、パスしているか判断する」が機械化されていない
      * 見落とし
      * 後々のリグレッションテストとしての資産化がされない

  * TDDでは、とりあえず雑な実装でグリーンにするステップがあるが、それは不要なのか？
    * TDDでなぜそれやるかというと、テストの正しさを担保するため？
      * テストの正しさ
        * テストにバグがある
        * テストが十分にケースをカバーしているか
      * 雑な実装でビジュアルスナップショットを取る
      * テストケースが正しいことは自明である

* ベースの「なんかいい感じに見えている」+コーナーケースで期待結果を自然言語で書く
    * ex. 「文字数が多いとはみ出した部分を…で表示してボタンの表示を壊さないようにする」← コーナーケース
    * ex. 「ボタンを押した時にコーラがカゴに表示される」← 通常のストーリー

* RED
--- ↑: テストにバグがないことの担保
* 雑なGREEN: どっち？
--- ↓: 適切な実装を行う（コードを綺麗にする、より一般的な実装を行う）
* リファクタ

nabeatsu関数

spec1: nab(1) = 1 && nab(2) = 2

spec2: nab(3) = aho nab(33) = aho 

nab x = 
  if (x % 3 == 0 || has3indec(x)) {
     return aho
  } else {
    reutnr x
  }

# 開発の流れ
* UIのデザイン(Figma)をつくる → コードを書く
    - 分業だとこっちの方が楽
    - ウォーターフォールっぽい
* UIのデザインとコーディングを一緒くたにやる
    - どうやったらうまくやれる?

* UIの細部をどこまでつめてから開発を始めるか？
    * UI: スケッチ → ワイヤーモック → Figma

* 今回のエクササイズだと、スケッチレベルからコーディングを始める（エンジニアドリブンなデザイン）
  * 先にパラメタライズされていない静的なHTML/CSSを描き切ってしまう→デザイナードリブンの進め方に近い
  * スケッチレベルだったら、部分的でキーとなる条件を、テストコードに書くこともできなくはない

* 実務でよくあるパターンだと、詳細に作られたデザインをコーディングで実現する（デザイナードリブンなデザイン）
  * そのデザイン自体をスナップショットにしてしまう


# 次回の動き 
・現段階の機能を盛り込んだ自販機のデザインを、スタティックなコードで仕上げる
・スナップショットテストとして登録することでテストケースとする
リファクタリング
・コンポーネントに分割していく
・パラメータ化 // -> 別のテストケースが必要？ // 今回はパラメータ化はされているので不要？

